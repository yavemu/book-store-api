import { Test, TestingModule } from '@nestjs/testing';
import { AuditSearchService } from '../audit-search.service';
import { IAuditSearchRepository } from '../../interfaces/audit-search.repository.interface';
import { AuditAction } from '../../enums/audit-action.enum';
import { PaginationDto } from '../../../../common/dto/pagination.dto';
import { AuditLog } from '../../entities/audit-log.entity';

describe('AuditSearchService', () => {
  let service: AuditSearchService;
  let repository: IAuditSearchRepository;

  const mockAuditSearchRepository = {
    getAuditTrail: jest.fn(),
    getUserAuditHistory: jest.fn(),
    getEntityAuditHistory: jest.fn(),
    getAuditsByAction: jest.fn(),
    getAuditsByEntityType: jest.fn(),
    searchAuditLogs: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuditSearchService,
        {
          provide: 'IAuditSearchRepository',
          useValue: mockAuditSearchRepository,
        },
      ],
    }).compile();

    service = module.get<AuditSearchService>(AuditSearchService);
    repository = module.get<IAuditSearchRepository>('IAuditSearchRepository');
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('getAuditTrail', () => {
    it('should call repository.getAuditTrail', async () => {
      const pagination: PaginationDto = { limit: 10, offset: 0, page: 1, sortBy: 'createdAt', sortOrder: 'DESC' };
      const expectedResult = { data: [], meta: { total: 0, page: 1, limit: 10, totalPages: 0, hasNext: false, hasPrev: false } };
      mockAuditSearchRepository.getAuditTrail.mockResolvedValue(expectedResult);
      const result = await service.getAuditTrail(pagination);
      expect(repository.getAuditTrail).toHaveBeenCalledWith(pagination);
      expect(result).toEqual(expectedResult);
    });
  });

  describe('getUserAuditHistory', () => {
    it('should call repository.getUserAuditHistory', async () => {
      const userId = 'user1';
      const pagination: PaginationDto = { limit: 10, offset: 0, page: 1, sortBy: 'createdAt', sortOrder: 'DESC' };
      const expectedResult = { data: [], meta: { total: 0, page: 1, limit: 10, totalPages: 0, hasNext: false, hasPrev: false } };
      mockAuditSearchRepository.getUserAuditHistory.mockResolvedValue(expectedResult);
      const result = await service.getUserAuditHistory(userId, pagination);
      expect(repository.getUserAuditHistory).toHaveBeenCalledWith(userId, pagination);
      expect(result).toEqual(expectedResult);
    });
  });

  describe('getEntityAuditHistory', () => {
    it('should call repository.getEntityAuditHistory', async () => {
        const entityId = 'entity1';
        const pagination: PaginationDto = { limit: 10, offset: 0, page: 1, sortBy: 'createdAt', sortOrder: 'DESC' };
        const expectedResult = { data: [], meta: { total: 0, page: 1, limit: 10, totalPages: 0, hasNext: false, hasPrev: false } };
        mockAuditSearchRepository.getEntityAuditHistory.mockResolvedValue(expectedResult);
        const result = await service.getEntityAuditHistory(entityId, pagination);
        expect(repository.getEntityAuditHistory).toHaveBeenCalledWith(entityId, pagination);
        expect(result).toEqual(expectedResult);
    });
  });

  describe('getAuditsByAction', () => {
    it('should call repository.getAuditsByAction', async () => {
        const action = AuditAction.CREATE;
        const pagination: PaginationDto = { limit: 10, offset: 0, page: 1, sortBy: 'createdAt', sortOrder: 'DESC' };
        const expectedResult = { data: [], meta: { total: 0, page: 1, limit: 10, totalPages: 0, hasNext: false, hasPrev: false } };
        mockAuditSearchRepository.getAuditsByAction.mockResolvedValue(expectedResult);
        const result = await service.getAuditsByAction(action, pagination);
        expect(repository.getAuditsByAction).toHaveBeenCalledWith(action, pagination);
        expect(result).toEqual(expectedResult);
    });
  });

  describe('getAuditsByEntityType', () => {
    it('should call repository.getAuditsByEntityType', async () => {
        const entityType = 'User';
        const pagination: PaginationDto = { limit: 10, offset: 0, page: 1, sortBy: 'createdAt', sortOrder: 'DESC' };
        const expectedResult = { data: [], meta: { total: 0, page: 1, limit: 10, totalPages: 0, hasNext: false, hasPrev: false } };
        mockAuditSearchRepository.getAuditsByEntityType.mockResolvedValue(expectedResult);
        const result = await service.getAuditsByEntityType(entityType, pagination);
        expect(repository.getAuditsByEntityType).toHaveBeenCalledWith(entityType, pagination);
        expect(result).toEqual(expectedResult);
    });
  });

  describe('searchAuditLogs', () => {
    it('should call repository.searchAuditLogs', async () => {
        const searchTerm = 'test';
        const pagination: PaginationDto = { limit: 10, offset: 0, page: 1, sortBy: 'createdAt', sortOrder: 'DESC' };
        const expectedResult = { data: [], meta: { total: 0, page: 1, limit: 10, totalPages: 0, hasNext: false, hasPrev: false } };
        mockAuditSearchRepository.searchAuditLogs.mockResolvedValue(expectedResult);
        const result = await service.searchAuditLogs(searchTerm, pagination);
        expect(repository.searchAuditLogs).toHaveBeenCalledWith(searchTerm, pagination);
        expect(result).toEqual(expectedResult);
    });
  });
});
